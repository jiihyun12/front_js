// 함수에서 {}은 영역
// 아무것도 없으면 저장공간의 영역이다.

// let user = {
//     name : "함지현",
//     age : 20,
//     height : 200,
//     mbti : "enfj"
// };

//  저장공간은 하나인데 값은 네 개가 들어갔다.
// 객체의 안에 담긴 친구들을 프로퍼티라고 부른다.
// 프로퍼티는 key와 value의 형식으로 되어있다.
// k : v 이런식으로 작성한다.

// key는 내가 원하는 값을 가져오기 위한 이름표 같은 역할을 한다.
// ex) user에서 name가져와, user에서 age 가져와...
// .을 사용해서 가져온다.
// ex) user.name
// console.log(user.name) // "함지현"
// key값을 가져오면 value를 가져오게 된다.

// 오른쪽에 있는 값을 왼쪽에다가 넣으면
// 왼쪽에 있는 값은 RAM이라는 저장장치가 기억하고있다가
// name이라는 저장공간을 하나 만들어서 
// "홍길동"이라는 값을 넣어놓고, 그곳에 접속할 수 있는 주소값을 들고 온다.



// let user = {
//     name : "함지현",
//     age : 20,
//     height : 200,
//     mbti : "enfj"
// };

// user.money = 20000; 
// console.log(user.money); // 20000 출력
// 안에 money라는 친구가 없지만 출력이 된다.
// name = "홍길동"; 
// console.log(user.name); // 홍길동 출력
// 원래 있던 name이라는 친구가 함지현에서 홍길동으로 바꼈다.

// 객체의 특징은 없는 값에 값을 넣으면 값이 추가가되고, 있는 값에 값을 넣으면 수정이 된다.




// 240830-day07-----------------------------------------------


// let user2 = new Object(); // new Object == {}
// console.log(user["mbti"]); 
// 대괄호표기법



// const post = {
//     id : 1,
//     title : "오늘은 즐거운 금요일 또 공부중~.~",
//     content : "자바스크립트 객체 연습",
//     name : "홍길동"
// };

// post.title = "와 불금엔 치킨";
// console.log(post.title); 

// 상수로 선언했는데 값이 바뀌었다.

// 자바스크립트는 싱글 쓰레드 언어이다. 
// 쓰레드는 일을 처리해주는 일꾼이다. 즉, 혼자 일을 하는 언어라는 말이다.
// 자바스크립트는 어떤 코드들을 번역할 때 혼자 일을 하기 때문에 잘못되면 그 다음 일처리를 할 수 없다.
// 자바스크립트에는 데이터를 저장하는 순서의 특징이 있다.
// 우선, 불변성을 갖고 있는 타입을 원시타입이라고 하는데, num, string, false, boolean 등과 같은 요소들인데
// 이런 요소들은 콜스택에 저장이 된다.
// 원시타입 외의 타입들인 객체 {}, 배열[], 등과같은 자료구조들은 동적, heap메모리에 저장이 된다.
// 자바스크립트는 다른 배열, 객체들의 값을 선언할 때 주소값을 참조하고 있다.
// 상수로 선언한 변수는 user라는 객체의 주소값{}이 바뀌지 말라고 하고있는것이라서
// 안에 있는 객체의 값이 바뀌더라도 내부에서 주소값이 바뀌면 되는 것이라 가능하다.


const products = {
    product1 : "지우개",
    product2 : "키보드",
    product3 : "마우스",
    product4 : "연필",
    product5 : "공책",
    product6 : "노트"
};

// 객체는 자료구조 key값의 set구조의 특성 때문에 순서가 없다.
// 자료구조 자체에는 순서가 없지만, key값은 규칙성이 있다.
// 규칙성이 있을 때 반복문(for문)을 사용할 수 있다.

// 향상된 for문, 빠른 for문 (객체나 배열에서 사용할 수 있다.)
for(let i in products){ 
    console.log(products)
}; 

// 객체는 0번부터 순서대로 index방번호를 가지고있다.
// 그 인덱스를 순서대로 가져와라! 하는 것이 빠른for문이다.
// 현재 index는 키값을 의미하고
// 이 키값을 순서대로 가져오게 된다.


for(let i in products){ 
    console.log(products[i])
}; 
// 대괄호 접근법을 사용하여
// i값으로 product에 접근한다면
// 원하는 값들을 들고올 수 있다.

// ------------------------------------------------------------------------------
// 빠른 for문을 이용하여 모든 유저의 point를 누적한 결과를 출력하기
// 10분

// const users = {
//     user1 : {
//         name : "홍길동",
//         age : 20,
//         point : 3000
//     },
//     user2 : {
//         name : "이순신",
//         age : 30,
//         point : 5000
//     },
//     user3 : {
//         name : "장보고",
//         age : 25,
//         point : 10000
//     },

// };

// result = 0;
// for(let i in users){
//     result += users[i].point; // 
// };
// console.log(result);




//  ------------------------------------------------------------------------------
const user1 = {name : "홍길동"};
const user2 = {name : "이순신"};
const user3 = {name : "장보고"};
const user4 = {name : "김철수"};
const user5 = {name : "김영희"};
const user6 = {name : "흰둥이"};
// 이렇게 반복되는 로직을 만들 때 프로토타입을 사용한다.

// 프로토타입(prototype)
// 객체 생성자 함수에 의해 생성되는 객체들이
// 공유하는 속성과 메서드를 저장하는 특수한 객체
function User(name){
    this.name = name; // this는 호출한 대상의 주소값(자기 자신의 주소값)을 가지고있다.                
};

const user7 = new User("홍길동"); // new는 "heap이라는 메모리 영역에 만들어라"라는 뜻이다.
const user8 = new User("이순신");
console.log(user7); // {name: '홍길동'};
console.log(user8); // 


